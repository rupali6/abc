import {
  AfterViewInit,
  ChangeDetectionStrategy, ChangeDetectorRef,
  Component, ElementRef, EventEmitter, forwardRef, Inject, Input, OnDestroy, OnInit, QueryList,
  ViewChild
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR, FormControl } from '@angular/forms';
import { MatOption, MatSelect } from '@angular/material';
import { Subject } from 'rxjs/Subject';
import { take, takeUntil } from 'rxjs/operators';

@Component({
  // tslint:disable-next-line:component-selector
  selector: 'mat-select-search',
  templateUrl: './mat-select-search.component.html',
  styleUrls: ['./mat-select-search.component.css'],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => MatSelectSearchComponent),
      multi: true
    }
  ],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class MatSelectSearchComponent implements OnInit, OnDestroy, AfterViewInit, ControlValueAccessor {

  @Input() selectControl?: FormControl;

  /** Label of the search placeholder */
  @Input() placeholderLabel = 'Search';

  /** Label to be shown when no entries are found. Set to null if no message should be shown. */
  @Input() noEntriesFoundLabel = 'No options found';

  /** Reference to the search input field */
  @ViewChild('searchSelectInput', { read: ElementRef }) searchSelectInput: ElementRef;

  /** Reference to the MatSelect options */
  public _options: QueryList<MatOption>;

  /** Previously selected values when using <mat-select [multiple]="true">*/
  private previousSelectedValues: any[];

  /** Whether the backdrop class has been set */
  private overlayClassSet = false;

  /** Event that emits when the current value changes */
  private change = new EventEmitter<string>();

  /** Subject that emits when the component has been destroyed. */
  private _onDestroy = new Subject<void>();

  /** Current search value */
  get value(): string {
    return this._value;
  }
  private _value: string;

  onChange: Function = (_: any) => { };
  onTouched: Function = (_: any) => { };

  constructor(@Inject(MatSelect) public matSelect: MatSelect,
    private changeDetectorRef: ChangeDetectorRef) {

  }

  ngOnInit() {
    // set custom panel class
    const panelClass = 'mat-select-search-panel';
    if (this.matSelect.panelClass) {
      if (Array.isArray(this.matSelect.panelClass)) {
        this.matSelect.panelClass.push(panelClass);
      } else if (typeof this.matSelect.panelClass === 'string') {
        this.matSelect.panelClass = [this.matSelect.panelClass, panelClass];
      } else if (typeof this.matSelect.panelClass === 'object') {
        this.matSelect.panelClass[panelClass] = true;
      }
    } else {
      this.matSelect.panelClass = panelClass;
    }

    // when the select dropdown panel is opened or closed
    this.matSelect.openedChange
      .pipe(takeUntil(this._onDestroy))
      .subscribe((opened) => {
        if (opened) {
          // focus the search field when opening
          this._focus();
        } else {
          // clear it when closing
          this._reset();
        }
      });

    // set the first item active after the options changed
    this.matSelect.openedChange
      .pipe(take(1))
      .pipe(takeUntil(this._onDestroy))
      .subscribe(() => {
        this._options = this.matSelect.options;
        this._options.changes
          .pipe(takeUntil(this._onDestroy))
          .subscribe(() => {
            const keyManager = this.matSelect._keyManager;
            if (keyManager && this.matSelect.panelOpen) {
              // avoid "expression has been changed" error
              setTimeout(() => {
                keyManager.setFirstItemActive();
              });
            }
          });
      });

    // detect changes when the input changes
    this.change
      .pipe(takeUntil(this._onDestroy))
      .subscribe(() => {
        setTimeout(() => {
          this.changeDetectorRef.detectChanges();
        });
      });

    this.initMultipleHandling();
  }

  ngOnDestroy() {
    this._onDestroy.next();
    this._onDestroy.complete();
  }

  ngAfterViewInit() {
    this.setOverlayClass();
  }

  /**
   * Handles the key down event with MatSelect.
   * Allows e.g. selecting with enter key, navigation with arrow keys, etc.
   * @param {KeyboardEvent} event
   * @private
   */
  _handleKeydown(event: KeyboardEvent) {
    if (event.keyCode === 32) {
      // do not propagate spaces to MatSelect, as this would select the currently active option
      event.stopPropagation();
    }

  }

  writeValue(value: string) {
    const valueChanged = value !== this._value;
    if (valueChanged) {
      this._value = value;
      this.change.emit(value);
    }
  }

  onInputChange(value) {
    const valueChanged = value !== this._value;
    if (valueChanged) {
      this._value = value;
      this.onChange(value);
      this.change.emit(value);
    }
  }

  onBlur(value: string) {
    this.writeValue(value);
    this.onTouched();
  }

  registerOnChange(fn: Function) {
    this.onChange = fn;
  }

  registerOnTouched(fn: Function) {
    this.onTouched = fn;
  }

  /**
   * Focuses the search input field
   * @private
   */
  public _focus() {
    if (!this.searchSelectInput) {
      return;
    }
    // save and restore scrollTop of panel, since it will be reset by focus()
    // note: this is hacky
    const panel = this.matSelect.panel.nativeElement;
    const scrollTop = panel.scrollTop;

    // focus
    this.searchSelectInput.nativeElement.focus();

    panel.scrollTop = scrollTop;
  }

  /**
   * Resets the current search value
   * @param {boolean} focus whether to focus after resetting
   * @private
   */
  public _reset(focus?: boolean) {
    if (!this.searchSelectInput) {
      return;
    }
    this.searchSelectInput.nativeElement.value = '';
    this.onInputChange('');
    if (focus) {
      this._focus();
    }
  }

  /**
   * Sets the overlay class to correct offsetY
   * so that the selected option is at the position of the select box when opening
   */
  private setOverlayClass() {
    if (this.overlayClassSet) {
      return;
    }
    const overlayClass = 'cdk-overlay-pane-select-search';

    this.matSelect.overlayDir.attach
      .pipe(takeUntil(this._onDestroy))
      .subscribe(() => {
        // note: this is hacky, but currently there is no better way to do this
        this.searchSelectInput.nativeElement.parentElement.parentElement
          .parentElement.parentElement.parentElement.classList.add(overlayClass);
      });

    this.overlayClassSet = true;
  }


  /**
   * Initializes handling <mat-select [multiple]="true">
   * Note: to improve this code, mat-select should be extended to allow disabling resetting the selection while filtering.
   */
  private initMultipleHandling() {
    // if <mat-select [multiple]="true">
    // store previously selected values and restore them when they are deselected
    // because the option is not available while we are currently filtering
    if (this.matSelect.multiple && this.selectControl) {
      this.selectControl.valueChanges
        .pipe(takeUntil(this._onDestroy))
        .subscribe((values) => {
          let restoreSelectedValues = false;
          if (this._value && this._value.length
            && this.previousSelectedValues && Array.isArray(this.previousSelectedValues)) {
            if (!values || !Array.isArray(values)) {
              values = [];
            }
            const optionValues = this.matSelect.options.map(option => option.value);
            this.previousSelectedValues.forEach(previousValue => {
              if (values.indexOf(previousValue) === -1 && optionValues.indexOf(previousValue) === -1) {
                // if a value that was selected before is deselected and not found in the options, it was deselected
                // due to the filtering, so we restore it.
                values.push(previousValue);
                restoreSelectedValues = true;
              }
            });
          }

          if (restoreSelectedValues) {
            this.matSelect._onChange(values);
          }

          this.previousSelectedValues = values;
        });
    }
  }

}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------


<input matInput class="mat-select-search-input mat-select-search-hidden"/>

<div class="mat-select-search-inner" [ngClass]="{'mat-select-search-inner-multiple': matSelect.multiple}">
  <input matInput
         autocomplete="off"
         class="mat-select-search-input"
         #searchSelectInput
         (keydown)="_handleKeydown($event)"
         (input)="onInputChange($event.target.value)"
         (blur)="onBlur($event.target.value)"
         [placeholder]="placeholderLabel"
  />
  <button *ngIf="value"
          mat-icon-button
          aria-label="Clear"
          (click)="_reset(true)"
          class="mat-select-search-clear">
    <mat-icon>close</mat-icon>
  </button>
</div>

<div *ngIf="noEntriesFoundLabel && value && _options?.length === 0" class="mat-select-search-no-entries-found">
  {{noEntriesFoundLabel}}
</div>
++++++++++++++++++++++++++++++++++++++++++MAIN
import { Component, ViewChild,
  Input, Output,
  ViewEncapsulation, EventEmitter,
  OnChanges, OnInit, AfterViewInit, OnDestroy,
  SimpleChanges, ChangeDetectionStrategy } from '@angular/core';
import { FormControl } from '@angular/forms';
import { MatSelect, _getOptionScrollPosition, MatSelectChange } from '@angular/material';
import { Subject } from 'rxjs/Subject';
import { takeUntil } from 'rxjs/operators';

@Component({
  // tslint:disable-next-line:component-selector
  selector: 'mat-select-hybrid',
  templateUrl: './mat-select-hybrid.component.html',
  styleUrls: ['./mat-select-hybrid.component.css'],
  encapsulation: ViewEncapsulation.None,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class MatSelectHybridComponent implements OnChanges, OnInit, AfterViewInit, OnDestroy {
  @ViewChild('matSelect') matSelect: MatSelect;
  @Input() selectControl: FormControl;
  @Input() isRequired?: boolean;
  @Input() isMultiple?: boolean;
  @Input() labelClass?: string;
  @Input() label?: string;
  @Input() dataKey: string;
  @Input() dataDisplayValue: string;
  @Input() data: Array<any>;
  @Input() groupKey?: string;
  @Input() hasNone?: boolean;

  @Output() readonly selectionChange: EventEmitter<MatSelectChange>;

  _onDestroy: Subject<void>;

  filterControl: FormControl;
  filteredData: Array<any>;
  groupData: Array<any>;

  constructor() {
    this.selectionChange = new EventEmitter<MatSelectChange>();
    this._onDestroy = new Subject<void>();
    this.filterControl = new FormControl();
    this.filteredData = new Array<any>();
    this.groupData = new Array<any>();
  }

  ngOnChanges(changes: SimpleChanges) {
    if (changes && changes.data && changes.data.currentValue) {
      if (changes.data.currentValue.length) {
        this.filteredData = changes.data.currentValue.slice();
        if (!!this.groupKey) {
          this.groupData = this.getGroupData(this.filteredData, this.groupKey);
        }
      } else {
        this.filteredData = this.groupData = [];
      }
    }
  }

  ngOnInit() {
    this.filterControl.valueChanges
      .pipe(takeUntil(this._onDestroy))
      .subscribe(() => {
        this.filterOptions();
      });

    this.matSelect.openedChange
      .pipe(takeUntil(this._onDestroy))
      .subscribe((opened) => {
        if (!opened && this.groupKey && this.groupData && this.groupData.length) {
          if (this.groupData.find(x => x && !x.isVisible)) {
            this.groupData = this.groupData.map(x => ({ ...x, isVisible: true }));
          }
        }
      });
  }

  ngAfterViewInit() {
    (<any>this.matSelect)._getItemCount = () => {
      return (
        (<any>this.matSelect).options.length +
        this.groupData.length +
        (this.isMultiple && this.data && this.data.length ? 1 : 0)
      );
    };

    (<any>this.matSelect)._scrollActiveOptionIntoView = () => {
      const matSelect = <any>this.matSelect;
      const activeOptionIndex = matSelect._keyManager.activeItemIndex || 0;

      this.matSelect.panel.nativeElement.scrollTop = _getOptionScrollPosition(
        activeOptionIndex + this.groupData.length + (this.isMultiple && this.data && this.data.length ? 1 : 0),
        matSelect._getItemHeight(),
        matSelect.panel.nativeElement.scrollTop,
        matSelect.SELECT_PANEL_MAX_HEIGHT
      );
    };
  }

  ngOnDestroy() {
    this._onDestroy.next();
    this._onDestroy.complete();
  }

  filterOptions() {
    if (!this.data) {
      return;
    }
    // get the search keyword
    let search = this.filterControl.value;
    if (!search) {
      this.filteredData = this.data.slice();
      if (!!this.groupKey) {
        this.groupData = this.getGroupData(this.filteredData, this.groupKey);
      }
      return;
    } else {
      search = search.toLowerCase();
    }
    // filter the options
    this.filteredData = this.data.filter(option => option[this.dataDisplayValue].toLowerCase().indexOf(search) > -1).slice();

    if (!!this.groupKey) {
      this.groupData = this.getGroupData(this.filteredData, this.groupKey);
    }
  }

  getGroupData(dataSource: Array<any>, groupBy: string) {
    const groupData = this.groupBy(dataSource, groupBy);

    return Object.keys(groupData).map(key => {
      return {
        key: key,
        value: groupData[key],
        isVisible: true
      };
    });
  }

  groupBy(collection: Array<any>, key: string): Object {
    return collection.reduce(function (previousValue, currentValue) {
      (previousValue[currentValue[key]] = previousValue[currentValue[key]] || []).push(currentValue);
      return previousValue;
    }, {});
  }
}
-------------------------------------
<mat-form-field>
  <mat-label [ngClass]="labelClass">{{label}}</mat-label>
  <mat-select #matSelect
    disableOptionCentering
    [formControl]="selectControl"
    [required]="isRequired"
    [multiple]="isMultiple"
    (selectionChange)="selectionChange.emit($event)">

    <mat-select-search
      [formControl]="filterControl"
      [selectControl]="selectControl"
      placeholderLabel="Search {{label}}"
      noEntriesFoundLabel="No {{label || 'Options'}} Found">
    </mat-select-search>

    <!-- Select All -->
    <mat-select-check *ngIf="isMultiple"
      class="select-hybrid-parent"
      [selectControl]="selectControl"
      [values]="filteredData"
      [dataKey]="dataKey"
      [isMultiple]="isMultiple">
    </mat-select-check>

    <!-- None option for single select -->
    <mat-option *ngIf="!isMultiple && !isRequired && hasNone" selected>None</mat-option>

    <ng-container [ngSwitch]="!!groupKey">

      <!-- For group data, create groups -->
      <ng-container *ngSwitchCase="true">
        <ng-container *ngFor="let group of groupData">
          <mat-select-check
            class="select-hybrid-parent"
            [selectControl]="selectControl"
            [isGroup]="true"
            [values]="group.value"
            [text]="group.key"
            [groupData]="groupData"
            [dataKey]="dataKey"
            [isMultiple]="isMultiple">
          </mat-select-check>

          <span class="select-hybrid-child" [ngStyle]="{'display': group.isVisible ? 'block' : 'none'}">
            <mat-option *ngFor="let item of group.value" [value]="item[dataKey]">
              {{item[dataDisplayValue]}}
            </mat-option>
          </span>
        </ng-container>
      </ng-container>

      <!-- no group options -->
      <ng-container *ngSwitchDefault>
        <mat-option *ngFor="let item of filteredData" [value]="item[dataKey]">
          {{item[dataDisplayValue]}}
        </mat-option>
      </ng-container>

    </ng-container>

  </mat-select>
  <mat-error *ngIf="selectControl.hasError('required')">{{label || 'Field'}} is required.</mat-error>
</mat-form-field>
--------------------------------------------------------
poc/app++++++++++++++++++++++
-----------------------------------------------------
import { Component, OnInit, VERSION } from '@angular/core';
import { FormGroup, FormBuilder } from '@angular/forms';

interface Territory {
  state: string;
  cityID: number;
  cityName: string;
}

@Component({
  selector: 'my-app',
  templateUrl: './app.component.html',
  styleUrls: [ './app.component.css' ]
})
export class AppComponent implements OnInit {
  version = VERSION;
  exampleForm: FormGroup;
  options: Array<Territory>;

  constructor(private formBuilder: FormBuilder) {
    this.options = this.getOptions();
  }

  ngOnInit() {
    this.initFormGroup();
  }

  initFormGroup() {
    this.exampleForm = this.formBuilder.group({
      singleSelect: [''],
      singleSelectGroup: [''],
      multiSelect: [''],
      multiSelectGroup: ['']
    });
  }

  getOptions(): Territory[] {
    return [
      { state: 'Alabama', cityID: 1, cityName: 'Alexander City' },
      { state: 'Alabama', cityID: 2, cityName: 'Andalusia' },
      { state: 'Alabama', cityID: 3, cityName: 'Anniston' },
      { state: 'Alabama', cityID: 4, cityName: 'Athens' },
      { state: 'Alabama', cityID: 5, cityName: 'Atmore' },
      { state: 'Alabama', cityID: 6, cityName: 'Auburn' },
      { state: 'Illinois', cityID: 7, cityName: 'Alton' },
      { state: 'Illinois', cityID: 8, cityName: 'Arlingotn Heights' },
      { state: 'Illinois', cityID: 9, cityName: 'Arthur' },
      { state: 'Illinois', cityID: 10, cityName: 'Aurora' },
      { state: 'Illinois', cityID: 11, cityName: 'Belleville' },
      { state: 'Illinois', cityID: 12, cityName: 'Belvidere' },
      { state: 'Illinois', cityID: 13, cityName: 'Bloomington' },
      { state: 'Illinois', cityID: 14, cityName: 'Brookfield' },
      { state: 'Illinois', cityID: 15, cityName: 'Cahokia' },
      { state: 'Illinois', cityID: 16, cityName: 'Cairo' },
      { state: 'Illinois', cityID: 17, cityName: 'Calumet City' },
      { state: 'Illinois', cityID: 18, cityName: 'Canton' },
      { state: 'New Jersey', cityID: 19, cityName: 'Asbury Park' },
      { state: 'New Jersey', cityID: 20, cityName: 'Atlantic City' },
      { state: 'New Jersey', cityID: 21, cityName: 'Bayonne' },
      { state: 'New Jersey', cityID: 22, cityName: 'Bloomfield' },
      { state: 'New Jersey', cityID: 23, cityName: 'Bordentown' },
      { state: 'New Jersey', cityID: 24, cityName: 'Bound Brook' },
      { state: 'New Jersey', cityID: 25, cityName: 'Bridgeton' },
      { state: 'New Jersey', cityID: 26, cityName: 'Burlington' },
      { state: 'New Jersey', cityID: 27, cityName: 'Caldwell' },
      { state: 'New Jersey', cityID: 28, cityName: 'Camden' },
      { state: 'New Jersey', cityID: 29, cityName: 'Cape May' },
      { state: 'New Jersey', cityID: 30, cityName: 'Clifton' },
      { state: 'New Jersey', cityID: 31, cityName: 'Cranford' },
      { state: 'New Jersey', cityID: 32, cityName: 'East Orange' },
      { state: 'New Jersey', cityID: 33, cityName: 'Edison' },
      { state: 'New Jersey', cityID: 34, cityName: 'Elizabeth' },
      { state: 'New Jersey', cityID: 35, cityName: 'Englewood' },
      { state: 'New Jersey', cityID: 36, cityName: 'Fort Lee' },
      { state: 'New Jersey', cityID: 37, cityName: 'Glassboro' },
      { state: 'New Jersey', cityID: 38, cityName: 'Hackensack' },
      { state: 'New Jersey', cityID: 39, cityName: 'Haddonfield' },
      { state: 'New Jersey', cityID: 40, cityName: 'Hoboken' },
      { state: 'New Jersey', cityID: 41, cityName: 'Irvington' },
      { state: 'New Jersey', cityID: 42, cityName: 'Jersey City' },
      { state: 'New Jersey', cityID: 43, cityName: 'Lakehurst' }
    ];
  }
}
---------------------------------------------------------
<mat-toolbar color="primary">
  Angular 6 - Mat Select Hybrid
</mat-toolbar>
<div class="base-container">

  <h2>Single Selection</h2>
  <div class="mdl-grid">
    <div class="mdl-cell mdl-cell--2-col">
      <mat-select-hybrid
        [selectControl]="exampleForm.get('singleSelect')"
        label="Single Select"
        [data]="options"
        [hasNone]="true"
        dataKey="cityID"
        dataDisplayValue="cityName">
      </mat-select-hybrid>
    </div>
    <div class="mdl-cell mdl-cell--2-col">
      <mat-select-hybrid
        [isRequired]="true"
        [selectControl]="exampleForm.get('singleSelectGroup')"
        label="Single Select - Group"
        [data]="options"
        dataKey="cityID"
        dataDisplayValue="cityName"
        groupKey="state">
      </mat-select-hybrid>
    </div>
  </div>

  <h2>Multiple Selection</h2>
  <div class="mdl-grid">
    <div class="mdl-cell mdl-cell--2-col">
      <mat-select-hybrid
        label="Multiple Select"
        [selectControl]="exampleForm.get('multiSelect')"
        [isMultiple]="true"
        [data]="options"
        dataKey="cityID"
        dataDisplayValue="cityName">
      </mat-select-hybrid>
    </div>
    <div class="mdl-cell mdl-cell--2-col">
      <mat-select-hybrid
        [selectControl]="exampleForm.get('multiSelectGroup')"
        [isMultiple]="true"
        label="Multiple Select - Group"
        groupKey="state"
        [data]="options"
        dataKey="cityID"
        dataDisplayValue="cityName">
      </mat-select-hybrid>
    </div>
  </div>

  <span class="version-info">Current build: {{version.full}}</span>
</div>
